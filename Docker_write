1. Docker

 1) 정의 : 어플리케이션을 패키징 할 수 있는 Tool

  - 컨테이너 안에 어플리케이션과 시스템 툴, 환경설정, 

    모든 dependency에 묶어서 어떤 운영체제에든 쉽게 배포 및 구동 가능하게 하는 도구.

​

 2) 배경

  - 어플리케이션 구동하는 데, 소스파일만을 배포 및 구동할 수 없음. 

  - 외부 라이브러리, 환경변수 설정 등 실행하고자 하는 pc와 서버에 모두 설정값을 매기는 건 

    오류 발생과 번거로움이 존재. 버전 차이에 따라 문제 발생하기도 함.

  - 어플리케이션 구동하기 위한 일련의 모든 걸 도커 컨테이너 안에 담아두어, 어떤 PC든 어디서든 가능함.    - 버전과 서버 문제 차이를 줄일 수 있음.


 

​

* 도커(Container)와 VM(가상머신) 차이

* Docker : 컨테이너 만들고 배포, 구동시키는 역할

​

VM(Virtual Muchin)

Container

개념

한 운영체제 위에서 동일 어플리케이션을 

각각 독립된 공간, 다른 환경에서 구동되기 위해선

VM 통해서 구동해야 했음.

VM은 각각 운영체제 포함함 

=> mac 위에서 window linux 구동 가능해짐

(하드웨어-소프트웨어-각각 가상 머신 생성)

VM에서 경량화됨

하드웨어에 설치된 운영체제 Host OS에서 

컨테이너 엔진(=docker) 소프트웨어 설치 시, 

개별 컨테이너 만들어서, 각각 어플리케이션을 

고립된 환경에서 구동가능토록 해줌.

​

Container Engine이 HostOS에 접근해서 

필요한 사항을 처리함.

특징

각각의 가상머신에서 

모든 운영체제를 포함하기에 무거워짐

부팅하는데 비교적 오랜 시간 소요

컴퓨터, 운영체제, 하드웨어의 자원 많이 소모

VM과 달리 운영체제 포함되지 않고, 

Host OS를 공유해 구동됨.

=> 운영체제가 없어 컨테이너가 가벼워짐


​

* 컨테이너 만드는 방법

1. dockerfile 제작

2. image 만들어서 컨테이너 구동

  +) 도커파일 

     -> 컨테이너 어떻게 만드는 지 레시피와 같음.

     -> 아래와 같은 기능을 담음 

       app 구동 위해 꼭 필요한 파일 무엇인가?

       어떤 프레임워크? 라이브러리? 외부 디펜던시 명시

       환경 변수 설정, 어떻게 구동해야할지 스크립트 포함 가능

​

       => 도커 파일 기반 이미지 만들기 가능

             이미지 만들기 위해 어플리케이션 실행에 필요한 

             코드, 런타임 환경, 시스템 툴(라이브러리), 모든 세팅 포함되어 있음.

​

컨테이너 안에서 어플리케이션이 동작한다.

==어플리케이션 이미지를 활용해 구동한다.

이미지==클래스라고 볼 수 있음. 이미지 이용해 어플리케이션 동작하는 각각 컨테이너 만들기 가능.

이미지는 어플리케이션 캡쳐할 상태 그대로이기에 이미지 고정불변함.

동작 어플리케이션은 파일 생성, 수정 가능.

각 컨테이너에서 수정된 파일이 있어도 이미지 영향 미치지 않음.

이미지 == 클래스

컨테이너 == 멤버변수라 칭할 수 있음.

​

​

​

*컨테이너 배포 방법


깃과 깃허브와 유사.

내 로컬머신에서 이미지 만들어, 깃허브와 같은 Container Registry에 내가 만든 이미지 push한 후,

필요한 서버나 다른 개발자 pc에서 내가 만든 이미지 가져와서 그걸 그대로 실행하면 됨.

이때 실행할 곳에서는 docker설치 필요


이미지 업로드 레지스트리는 public private존재


로컬머신과 서버에 도커 설치

1. 도커 파일 작성한 후,

2. 어플리케이션 이미지 제작

3. 이미지를 컨테이너 레지스트리에 올려서

4. 서버에서 다운로드 받아 실행





* 도커 파일 생성
1. 새 파일 만들기 - dockerfile명 입력 - 도커 파일 생성


2. 도커 베이스 이미지 설정
from node:16-alpine
//16 : 노드 버전  alpine : 최소 단위 리눅스 버전 의미.
- 도커 이미지를 만들 때, 베이스 이미지 존재.
 - 기본적으로 리눅스 이미지 사용하기도 함.
 - 노드의 경우, 미리 만들어진 노드 이미지 활용 가능


3. 도커 이미지(컨테이너) 안에서 어떤 경로로 실행할 지 명시
WORKDIR /app //어떤 디렉토리, 어플리케이션 복사해올지 명시


4. 프로젝트 파일 복사
 4-1) json 파일(라이브러리) 복사
Copy package.json package-lock.json  //work directory - app 경로 안에 copy 명령어 통해서 json 파일 2개를 복사.
 - 도커파일에서 카피, 명령어 수행 -> 레이어 시스템으로 구성되어 있음.
 - 빈번되는 파일은 맨 마지막에 작성하는 게 좋음.
 - 소스코드 담고 있는 index.js가 다른 dependency package.json파일에 비해 빈번히 변경 발생할 것.
 - 그렇기에 맨 처음은 json파일 우선 작성, 가장 마지막이 index.js파일이 될 것.

 4-2) 라이브러리 설치
RUN npm install
RUN npm ci //프로젝트 개발 버전과 실제 설치 버전과의 차이 문제를 해결

 4-3) 소스 파일 복사
COPY index.js .


5. 도커 컨테이너 시작 시 실행할 명령어 기재
 - ENTRYPOINT : 컨테이너가 시작될 때 실행될 명령어를 정의하는 역할.(주어진 인자를 전달)
 - ["node", "index.js"] : 배열 형태로 실행할 명령어 인자 나열

​
6. Terminal - New Terminal 클릭


7. 도커이미지 기반되는 도커명과 신규 도커 이미지명 명령어로 작성
docker build -f Dockerfile -t fun-docker .  
//현 경로에 Dockerfile 코드를 기반해서 fun-docker라는 이미지명으로 도커 이미지 만들거야.
/*.(점) : build context  도커에게 필요한 파일 안내. 
최상위 경로에 있는 도커 파일에게 현재 명령어 수행하는 경로를 지정함.
-f 도커파일명 : 어떤 도커파일 사용할 것인지 명시
-t 이미지명 : 도커 이미지명 부여 가능*/


8. 이미지 파일 생성 확인
docker images


9. 도커 실행(포트 연결 및 백그라운드 실행)
docker run -d -p 8088:8088 fun-docker
// -d (detached mode 분리모드) : 다른 작업으로 인해 컨테이너의 도커 설정이 지연될 수 있는 상황에서 상관없이  백그라운드에서 도커 설정 실행하도록 함.
// -p : 로컬 호스트의 포트와 컨테이너의 포트 연결 작업


10. 현재 실행중인 컨테이너 목록 확인
docker ps
//docker process status 
//현재 실행중인 컨테이너 목록 확인


11. 구동한 컨테이너 로그 확인
docker logs [컨테이너 아이디명]
//도커 컨테이너 로그 확인


12. DockerHub에 이미지 업로드(이미지 배포)
